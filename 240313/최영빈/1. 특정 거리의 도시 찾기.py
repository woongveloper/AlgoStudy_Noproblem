'''
어떤 나라에는 1 〜 N번까지의 도시와 M개의 단방향 도로가 존재합니다.
모든 도로의 거리는 1 입니다.

이때 특정한 도시 X로부터 출발하여 도달할 수 있는 모든 도시 중에서
최단 거리가 정확히 K인 모든 도시의 번호를 출력하는 프로그램을 작성하세요.

또한 출발 도시 X에서 출발 도시 X로 가는 최단 거 리는 항상 0이라고 가정합니다

예를 들어 N = 4. K = 2. X = 1일 때 다음과 같이 그래프가 구성되어

이때 1 번 도시에서 출발하여 도달할 수 있는 도시 중에서 최단 거리가 2인 도시는 4번 도시뿐입니다. 
2번과 3번 도시의 경우, 최단 거리가 1 이기 때문에 출력하지 않습니다.


  
입력 조건 
• 첫째 줄에 도시의 개수 N, 도로의 개수 M, 거리 정보 K, 출발 도시의 번호 X가 주어집니다.
(2 < N < 300,000,1 < M < 1,000,000.1 < K < 300,000,1 <X <N)

• 둘째 줄부터 M개의 줄에 걸쳐서 두 개의 자연수 A, 日가 주어지며, 각 자연수는 공백으로 구분합니다.
이는 A번 도시에서 B번 도시로 이동하는 단방향도로가존재한다는 의미입니다. (1 <A. B<N) 
단,A와 日는 서로 다른 자연수입니다.

출력 조건 
• X로부터 출발하여 도달할 수 있는 도시 중에서, 최단 거리가 K인 모든 도시의 번호를 한 줄에 하나씩오름차순으로 출력합니다.
• 이때 도달할 수 있는 도시 중에서, 최단 거리가 K인 도시가 하나도 존재하지 않으면 -1 을 출력합니다.

bfs로 풀어보기
'''

N, M, K, X = map(int, input().split())  # 도시개수N, 도로개수M, 최단거리정보K, 출발도시번호X

arr = [[] for _ in range(N + 1)]  # 간선 정보 저장할 2차원 리스트

for _ in range(M):
    A, B = map(int, input().split())
    arr[A].append(B)  # 간선 정보 저장

# BFS로 최단 거리 계산
distance = [-1] * (N + 1)  # 모든 도시에 대한 최단 거리 초기화
distance[X] = 0  # 출발도시에서 출발도시는 거리 0으로 설정

queue = []          # 빈 큐 만들기
queue.append(X)     # 시작도시 추가하기

while queue:    # 큐가 비어있지 않은 동안 무한 반복
    now = queue.pop(0)  # 현재 도시를 큐에서 꺼내오기 #팝제로가 시간이 엄청 들어서 큐 부분을 덱큐로 바꾼다.!!!!!!!!!!
    for i in arr[now]:  # 현재 도시와 연결된 도시들을 반복순회
        if distance[i] == -1:   # 방문한 적이 없는 도시라면
            distance[i] = distance[now] + 1 # 해당 도시까지 거리에 +1을 하고 
            queue.append(i)                 # 큐에 도시 저장
          

result = 0
for i in range(1, N + 1):   # 모든 거리를 순회하면서
    if distance[i] == K:    # K와 같다면 출력
        print(i)
        result += 1

if result == 0:
    print(-1)   
        


# 이게 4만 나와야 하는데 -1 -1 -1 4가 나온다. # else문을 없애면 또 -1 나와야할때 아예 안나온다...
## 백준 시간 초과

'''
4 4 2 1
1 2
1 3
2 3
2 4

4

4 3 2 1
1 2
1 3
1 4

-1

4 4 1 1
1 2
1 3
2 3
2 4

2
3
'''
